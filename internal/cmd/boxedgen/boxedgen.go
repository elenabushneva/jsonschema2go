package main

import (
	"bytes"
	"go/format"
	"log"
	"os"
	"text/template"
	"unicode"
)

var tmpl = template.Must(template.New("").Parse(`// Code generated by internal/cmd/boxedgen/boxedgen.go DO NOT EDIT.
package boxed

import (
	"encoding/json"
	"errors"
)

var (
	// ErrMarshalUnset is returned when you attempt to marshal an unset var
	ErrMarshalUnset = errors.New("marshalling unset var")
	// ErrNullInvalid is returned if marshalling null into a boxed field is attempted
	ErrNullInvalid  = errors.New("null is invalid")
)

{{ range . -}}
// {{ .WrapperName }} wraps a {{ .TypeName }} and provides information about whether or not the variable has been 
// explicitly set.
type {{ .WrapperName }} struct {
	{{ .WrapperName }} {{ .TypeName }}
	Set bool
}

// MarshalJSON writes the field as JSON; it is an error to marshal an unset field, in which case ErrMarshalUnset is
// returned. Otherwise, the field is marshalled as the value of its primitive.
func (m {{ .WrapperName }}) MarshalJSON() ([]byte, error) {
	if !m.Set {
		return nil, ErrMarshalUnset
	}
	return json.Marshal(m.{{ .WrapperName }})
}

// UnmarshalJSON unmarshals JSON into a {{ .WrapperName }}. Null is explicitly disallowed. Set is set true when a
// value is successfully unmarshalled.
func (m *{{ .WrapperName }}) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		return ErrNullInvalid
	}
	if err := json.Unmarshal(data, &m.{{ .WrapperName }}); err != nil {
		return err
	}
	m.Set = true
	return nil
}
{{ end -}}
`))

func main() {
	type typeInfo struct {
		WrapperName, TypeName string
	}

	var types []typeInfo
	for _, t := range []string{
		"int64",
		"float64",
		"string",
		"bool",
	} {
		t2 := []rune(t)
		t2[0] = unicode.ToUpper(t2[0])
		types = append(types, typeInfo{string(t2), t})
	}

	var w bytes.Buffer
	if err := tmpl.Execute(&w, types); err != nil {
		log.Fatal(err)
	}

	data, err := format.Source(w.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create("pkg/boxed/boxed.go")
	if err != nil {
		log.Fatal(err)
	}
	func() {
		defer f.Close()
		_, err = f.Write(data)
		return
	}()
	if err != nil {
		log.Fatal(err)
	}
}
